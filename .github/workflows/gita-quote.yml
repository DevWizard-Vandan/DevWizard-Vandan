name: Update Bhagavad Gita Verse

on:
  schedule:
    - cron: "0 0 * * *"  # Daily at midnight UTC
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-verse:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Calculate and Fetch Today's Verse
        run: |
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # BHAGAVAD GITA VERSE ROTATOR
          # Cycles through all 700 verses in serial order
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          
          # Use a loop to retry or fallback if needed
          fetch_verse() {
            local chapter=$1
            local verse=$2
            local url="https://vedicscriptures.github.io/slok/${chapter}/${verse}"
            
            echo "üåê Fetching from: $url"
            response=$(curl -s -f "$url")
            exit_code=$?
            
            if [ $exit_code -ne 0 ] || [ -z "$response" ]; then
              echo "‚ùå Failed to fetch verse (curl error or empty response)"
              return 1
            fi

            # Validate JSON
            if ! echo "$response" | jq -e . >/dev/null 2>&1; then
               echo "‚ùå Invalid JSON response: $response"
               return 1
            fi
            
            echo "$response"
            return 0
          }

          VERSES_PER_CHAPTER=(47 72 43 42 29 47 30 28 34 42 55 20 35 27 20 24 28 78)
          
          START_DATE="2026-01-01"
          TODAY_SECONDS=$(date +%s)
          START_SECONDS=$(date -d "$START_DATE" +%s)
          DAYS_DIFF=$(( (TODAY_SECONDS - START_SECONDS) / 86400 ))
          
          # Ensure positive DAYS_DIFF
          if [ $DAYS_DIFF -lt 0 ]; then DAYS_DIFF=0; fi

          VERSE_INDEX=$(( DAYS_DIFF % 700 ))
          
          echo "üìÖ Day $DAYS_DIFF since start"
          echo "üìñ Verse index: $VERSE_INDEX"
          
          CHAPTER=1
          REMAINING=$VERSE_INDEX
          
          for i in "${!VERSES_PER_CHAPTER[@]}"; do
            CHAPTER_VERSES=${VERSES_PER_CHAPTER[$i]}
            if [ $REMAINING -lt $CHAPTER_VERSES ]; then
              CHAPTER=$((i + 1))
              VERSE=$((REMAINING + 1))
              break
            fi
            REMAINING=$((REMAINING - CHAPTER_VERSES))
          done
          
          echo "üéØ Target: Chapter $CHAPTER, Verse $VERSE"
          
          # Attempt fetch
          RESPONSE=$(fetch_verse $CHAPTER $VERSE)
          
          if [ $? -ne 0 ]; then
             echo "‚ö†Ô∏è Fetch failed. Using fallback verse (BG 2.47)."
             RESPONSE='{"slok": "‡§ï‡§∞‡•ç‡§Æ‡§£‡•ç‡§Ø‡•á‡§µ‡§æ‡§ß‡§ø‡§ï‡§æ‡§∞‡§∏‡•ç‡§§‡•á ‡§Æ‡§æ ‡§´‡§≤‡•á‡§∑‡•Å ‡§ï‡§¶‡§æ‡§ö‡§® |\n‡§Æ‡§æ ‡§ï‡§∞‡•ç‡§Æ‡§´‡§≤‡§π‡•á‡§§‡•Å‡§∞‡•ç‡§≠‡•Ç‡§∞‡•ç‡§Æ‡§æ ‡§§‡•á ‡§∏‡§ô‡•ç‡§ó‡•ã‡§Ω‡§∏‡•ç‡§§‡•ç‡§µ‡§ï‡§∞‡•ç‡§Æ‡§£‡§ø ||‡•®-‡•™‡•≠||", "transliteration": "karma·πáyevƒÅdhikƒÅraste mƒÅ phale·π£u kadƒÅcana ...", "siva": {"et": "Thy right is to work only, but never with its fruits; let not the fruits of action be thy motive, nor let thy attachment be to inaction."}}' # Minimal fallback JSON
             CHAPTER=2
             VERSE=47
             # We construct a minimal valid JSON for the parser below to allow workflow to pass
          fi

          # Extract data using jq - using null coalescing for robustness
          SLOK=$(echo "$RESPONSE" | jq -r '.slok // "Update failed"' | sed 's/\\n/\n/g')
          # Try multiple translation sources
          TRANSLATION=$(echo "$RESPONSE" | jq -r '(.siva.et // .tej.ht // .purohit.et // .chinmay.et // .san.et // "Translation unavailable")' | sed 's/"/\\"/g') 
          
          if [ "$SLOK" == "Update failed" ]; then
             echo "‚ùå Critical error: Could not extract slok from response."
             exit 1
          fi

          echo "üìú Sanskrit found"
          echo "üî§ Translation found"
          
          # Create verse block template
          cat > /tmp/verse_block.txt << 'VERSE_TEMPLATE'
          <img src="https://img.shields.io/badge/‡§Ö‡§ß‡•ç‡§Ø‡§æ‡§Ø_CHAPTER_NUM-‡§∂‡•ç‡§≤‡•ã‡§ï_VERSE_NUM-FF9933?style=flat-square&labelColor=0d1117"/>
          
          ```sanskrit
          SANSKRIT_TEXT
          ```
          
          <sub>
          
          **TRANSLATION_TEXT**
          
          *‚Äî Bhagavad Gita, Chapter CHAPTER_NUM, Verse VERSE_NUM*
          
          </sub>
          VERSE_TEMPLATE
          
          # Python script to safely replace content in README
          python3 << EOF
          import re
          import os
          
          template_path = '/tmp/verse_block.txt'
          readme_path = 'README.md'
          
          try:
              with open(template_path, 'r', encoding='utf-8') as f:
                  template = f.read()
              
              with open(readme_path, 'r', encoding='utf-8') as f:
                  readme = f.read()
              
              # Inputs
              chapter = "$CHAPTER"
              verse = "$VERSE"
              slok = """$SLOK""" 
              translation = """$TRANSLATION"""
              
              # Pre-process slok: replace pipes with danda
              slok = slok.replace('|', '‡•§')
              
              # Fill template
              new_verse_block = template.replace('CHAPTER_NUM', chapter).replace('VERSE_NUM', verse)
              new_verse_block = new_verse_block.replace('SANSKRIT_TEXT', slok)
              new_verse_block = new_verse_block.replace('TRANSLATION_TEXT', translation)
              
              # Define markers in README
              # We look for the badge image start and the closing sub tag
              # Reuse robust markers from previous attempt or standard ones
              
              # Broad regex to capture the specific daily gita section
              # From: <img src="https://img.shields.io/badge/‡§Ö‡§ß‡•ç‡§Ø‡§æ‡§Ø_ ...
              # To: ... <sub>üìÖ Updates daily via GitHub Actions ‚Ä¢ Cycles through all 700 verses</sub>
              
              # NOTE: The previous regex was: r'(<img src="https://img\.shields\.io/badge/‡§Ö‡§ß‡•ç‡§Ø‡§æ‡§Ø_\d+-‡§∂‡•ç‡§≤‡•ã‡§ï_\d+.*?<sub>üìÖ Updates daily)'
              # This relies on the specific content being present.
              # A safer way is using unique HTML comment markers if available, but we must work with existing text.
              # We will try to locate the table cell content.
              
              # Strategy: Locate the table cell containing the verse.
              # It starts after <td align="center" width="800">
              # It ends before <sub>üìÖ Updates daily
              
              start_marker = '<td align="center" width="800">'
              end_marker_text = '<sub>üìÖ Updates daily'
              
              start_idx = readme.find(start_marker)
              end_idx = readme.find(end_marker_text)
              
              if start_idx != -1 and end_idx != -1:
                  # We want to replace everything BETWEEN start_marker and end_marker
                  # But wait, end_marker is showing as an anchor for the footer of that cell.
                  # Let's inspect the structure from file view.
                  
                  # The structure is:
                  # <td align="center" width="800">
                  # [THE VERSE BLOCK WE WANT TO REPLACE]
                  # <br>
                  # <sub>üìÖ Updates daily ...
                  
                  # So we replace from (start_idx + len(start_marker)) up to found end_idx
                  # But we need to keep the <br> or add it. The template does not have the trailing <br>.
                  # The template ends with </sub>.
                  
                  prefix = readme[:start_idx + len(start_marker)]
                  suffix = readme[end_idx:]
                  
                  # The new content should simply differ by a few newlines
                  final_content = prefix + '\n\n' + new_verse_block.strip() + '\n\n<br>\n\n' + suffix
                  
                  with open(readme_path, 'w', encoding='utf-8') as f:
                      f.write(final_content)
                  print("‚úÖ README updated successfully.")
                  
              else:
                  print("‚ùå Could not find verse markers. START: {}, END: {}".format(start_idx, end_idx))
                  exit(1)
                  
          except Exception as e:
              print(f"‚ùå Python error: {e}")
              exit(1)
          EOF

      - name: Commit and Push Changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "Gita Bot üìñ"
          git add README.md
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            CHAPTER=$(grep -oP '(?<=Chapter )\d+' README.md | head -1)
            VERSE=$(grep -oP '(?<=Verse )\d+' README.md | head -1)
            git commit -m "üìñ Daily Gita: Chapter $CHAPTER, Verse $VERSE"
            git push
            echo "‚úÖ Pushed new verse!"
          fi
